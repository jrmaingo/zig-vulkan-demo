const std = @import("std");
const c = @cImport({
    @cInclude("SDL2/SDL.h");
    @cInclude("vulkan/vulkan.h");
});

const VkAllocator = struct {
    allocator: *std.mem.Allocator,
    // maps addr to len
    len_map: LenMap,

    const allocType = u8;
    const exact = std.mem.Allocator.Exact.at_least;
    const LenMap = std.AutoHashMap([*]u8, AllocData);

    const AllocData = struct {
        size: usize,
        alignment: u29,
    };

    fn init(allocator: *std.mem.Allocator) VkAllocator {
        return VkAllocator{
            .allocator = allocator,
            .len_map = LenMap.init(allocator),
        };
    }

    fn getCallbacks(self: *VkAllocator) c.VkAllocationCallbacks {
        return c.VkAllocationCallbacks{
            .pUserData = self,
            .pfnAllocation = vkAllocate,
            .pfnReallocation = vkReallocate,
            .pfnFree = vkFree,
            .pfnInternalAllocation = null,
            .pfnInternalFree = null,
        };
    }

    // TODO hack to get around comptime alignment for now
    // https://github.com/ziglang/zig/issues/7172
    fn allocAligned(self: *VkAllocator, alignment: u29, size: usize) std.mem.Allocator.Error![]align(1) u8 {
        std.debug.assert(size != 0);
        comptime var i = 0;
        inline while (i < 29) : (i += 1) {
            // std.log.info("alloc i: {}", .{i});
            if (alignment == (1 << i)) {
                var res = try self.allocator.allocAdvanced(allocType, 1 << i, size, exact);
                errdefer self.allocator.free(res);

                // store addr->len mapping on successful allocation
                try self.len_map.put(res.ptr, .{ .size = size, .alignment = alignment });

                return res;
            }
        }
        unreachable;
    }

    fn reallocAligned(self: *VkAllocator, original: [*]u8, alignment: u29, size: usize) std.mem.Allocator.Error![]align(1) u8 {
        std.debug.assert(size != 0);
        const allocData = self.len_map.get(original).?;
        std.debug.assert(allocData.alignment >= alignment);
        var sizedOrignal = original[0..allocData.size];
        comptime var i = 0;
        inline while (i < 29) : (i += 1) {
            // std.log.info("realloc i: {}", .{i});
            if (alignment == (1 << i)) {
                var res = try self.allocator.reallocAdvanced(sizedOrignal, 1 << i, size, exact);
                errdefer self.allocator.free(res);

                // update addr->len mapping on successful reallocation
                try self.len_map.put(res.ptr, .{ .size = size, .alignment = alignment });

                return res;
            }
        }
        unreachable;
    }

    fn free(self: *VkAllocator, memory: [*]u8) void {
        const allocData = self.len_map.get(memory).?;
        var sizedMemory = memory[0..allocData.size];
        self.allocator.free(sizedMemory);
        _ = self.len_map.remove(memory);
    }
};

// TODO actually use allocationScope
fn vkAllocate(pUserData: ?*c_void, size: usize, alignment: usize, allocationScope: c.VkSystemAllocationScope) callconv(.C) ?*c_void {
    if (size == 0) {
        return null;
    }

    var allocator = @ptrCast(*VkAllocator, @alignCast(8, pUserData.?));
    if (allocator.allocAligned(@truncate(u29, alignment), size)) |res| {
        return @as(*c_void, res.ptr);
    } else |err| {
        std.log.err("alloc error {}", .{err});
        return null;
    }
}

fn vkReallocate(pUserData: ?*c_void, pOriginal: ?*c_void, size: usize, alignment: usize, allocationScope: c.VkSystemAllocationScope) callconv(.C) ?*c_void {
    if (size == 0) {
        vkFree(pUserData, pOriginal);
        return null;
    }

    if (pOriginal) |justOriginal| {
        var allocator = @ptrCast(*VkAllocator, @alignCast(8, pUserData.?));
        if (allocator.reallocAligned(@ptrCast([*]u8, justOriginal), @truncate(u29, alignment), size)) |res| {
            return @as(*c_void, res.ptr);
        } else |err| {
            std.log.err("alloc error {}", .{err});
            return null;
        }
    } else {
        return vkAllocate(pUserData, size, alignment, allocationScope);
    }
}

fn vkFree(pUserData: ?*c_void, pMemory: ?*c_void) callconv(.C) void {
    const justMemory = pMemory orelse return;
    var allocator = @ptrCast(*VkAllocator, @alignCast(8, pUserData.?));
    allocator.free(@ptrCast([*]u8, justMemory));
}

// workaround for now, remove later when @TypeOf works for global functions
// (this is taken from the code generated by translate-c)
pub inline fn VK_VERSION_MAJOR(version: anytype) u32 {
    return (@import("std").meta.cast(u32, version)) >> 22;
}
pub inline fn VK_VERSION_MINOR(version: anytype) u32 {
    return ((@import("std").meta.cast(u32, version)) >> 12) & 0x3ff;
}
pub inline fn VK_VERSION_PATCH(version: anytype) u32 {
    return (@import("std").meta.cast(u32, version)) & 0xfff;
}

fn vkPrintVersion() void {
    var version: u32 = 0;
    var res = c.vkEnumerateInstanceVersion(&version);
    if (res != c.VkResult.VK_SUCCESS) {
        std.log.err("enumerate instance version error {}", .{res});
    } else {
        std.log.info("version: {}.{}.{}", .{ VK_VERSION_MAJOR(version), VK_VERSION_MINOR(version), VK_VERSION_PATCH(version) });
    }
}

const MyError = error{
    UnknownSDL,
    UnknownVk,
};

fn vkInit(vkAllocator: *VkAllocator) anyerror!c.VkInstance {
    const vkInstanceCreateInfo = c.VkInstanceCreateInfo{
        .sType = c.VkStructureType.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
        .pNext = null,
        .flags = 0,
        .pApplicationInfo = null,
        .enabledLayerCount = 0,
        .ppEnabledLayerNames = null,
        .enabledExtensionCount = 0,
        .ppEnabledExtensionNames = null,
    };

    const vkAllocationCallbacks = vkAllocator.getCallbacks();
    var vkInstance: c.VkInstance = undefined;
    const res = c.vkCreateInstance(&vkInstanceCreateInfo, &vkAllocationCallbacks, &vkInstance);
    if (res != c.VkResult.VK_SUCCESS) {
        std.log.err("init failed! {}", .{res});
        return MyError.UnknownVk;
    } else {
        return vkInstance;
    }
}

pub fn main() anyerror!void {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();

    vkPrintVersion();

    var vkAllocator = VkAllocator.init(&arena.allocator);
    var vkInstance = try vkInit(&vkAllocator);
    defer {
        const vkAllocationCallbacks = vkAllocator.getCallbacks();
        c.vkDestroyInstance(vkInstance, &vkAllocationCallbacks);
    }

    var res_int = c.SDL_Init(c.SDL_INIT_VIDEO);
    if (res_int != 0) {
        return MyError.UnknownSDL;
    }
    var window = c.SDL_CreateWindow("vulkan-zig-demo", c.SDL_WINDOWPOS_CENTERED, c.SDL_WINDOWPOS_CENTERED, 1280, 720, c.SDL_WINDOW_VULKAN);
    defer c.SDL_DestroyWindow(window);

    return mainLoop();
}

fn draw() void {
    // TODO
}

fn mainLoop() anyerror!void {
    while (true) {
        var event: c.SDL_Event = undefined;
        if (c.SDL_PollEvent(&event) == 1) {
            switch (event.type) {
                c.SDL_QUIT => return,
                else => {
                    // std.log.info("unhandled event type {}", .{event.type});
                    continue;
                },
            }
        }

        draw();
    }
}

test "allocate, realloc and free" {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();

    var vkAllocator = VkAllocator.init(&arena.allocator);
    const userData = @as(?*c_void, &vkAllocator);

    var mem = vkAllocate(userData, @sizeOf(u32), 8, c.VkSystemAllocationScope.VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE).?;

    mem = vkReallocate(userData, mem, @sizeOf(u64), 8, c.VkSystemAllocationScope.VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE).?;

    vkFree(userData, mem);
}
